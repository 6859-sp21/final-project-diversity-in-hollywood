<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <title>Diversity in Hollywood</title>
  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">  
  <script src="https://d3js.org/d3.v5.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script>
  <script src="https://cdn.rawgit.com/RasmusFonseca/d3RangeSlider/master/d3RangeSlider.js"></script>
  <link href='https://fonts.googleapis.com/css?family=Didact Gothic' rel='stylesheet'>
  <link href="https://cdn.rawgit.com/RasmusFonseca/d3RangeSlider/master/d3RangeSlider.css" rel="stylesheet">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <style type="text/css">
    h1 { 
      color: 	#E6AB02; 
      font-family: 'Didact Gothic', sans-serif; 
      font-size: 3rem;
      line-height: 1; 
      margin-left: 20px;
      margin-top: 20px;
      margin-bottom: 0px;
      text-align: left; 
    }

    h2 {
      color: 	#E6AB02; 
      font-family: 'Didact Gothic', sans-serif;
      font-size: 2.0rem;
      line-height: 1; 
      margin-top: 5px;
      margin-left: 0px;
      text-align: left; 
    }
    body {
      background-color: rgb(29, 28, 28);
    }

    g.cell {
      background-color: blue;
    }

    h3 {
      color: white;
    }

    .main-caption {
      padding: 250px 80px 0px 80px;
      color: white;
    }

    #main-1 {
      display: flex;
      margin: auto;
      width: 1500px;
    }

    #header {
      background-color: #383838;
      position: fixed;
      width: 100%;
      color: white;
      height: 175px;
      z-index: 10;
    }

    #filter-instructions {
      font-size: 26px;
      width: 20%;
    }

    #filters {
      padding: 20px 0;
      z-index: 2;
    }

    .award-nav-option:hover {
      text-decoration: none;
      color: white;
    }

    #slider-section {
      width: 750px;
      margin: auto;
      padding-right: 10px;
    }

    #slider-container {
      position: relative;
      height:30px;
    }

    .slider {
      background-color: #E6AB02 !important;
    }

    .handle {
      height: 12px !important;
      width: 12px !important;
      border-color: black !important;
      background-color: black !important;
      border-radius: 10px;
    }

    #range-label {
      color: white;
      text-align: center;
      font-family: 'Didact Gothic', sans-serif;
      font-size: 30px;
    }

    #graph {
      /* so the graph doesn't go outside of the container on zoom */
      overflow: hidden;
      padding-top: 60px;
      cursor: pointer;
    }

    .sources {
      color: white;
      font-size: 16px;
      text-align: right;
      padding-top: 40px;
    }

    .caption {
      color: white;
      font-size: 15px;
    }

    #zoom {
      color: white;
      transform: translate(75px, 150px);
    }
    
    .stats {
      color: white;
      font-size: 15px;
    }

    div.tooltip {	
      position: absolute;			
      text-align: left;			
      /* width: 60px;					
      height: 28px;					 */
      font: 18px "Didact Gothic";		
      background: lightskyblue;	
      border: 0px;		
      border-radius: 7px;
      padding: 3px;			
      pointer-events: none;			
    }

    .nav-options {
      padding-top: 20px;
      padding-left: 40px;
      width: 15%;
      text-align: left;
    }

    .nav-option {
      color: #7E5E29 !important;
      font-size: 24px;
      text-decoration: none !important;
      transition: transform .2s !important; 
      display: block;
    }

    .nav-option:hover {
      transform: scale(1.04) !important;
    }

    .selected-nav-option {
      display: block;
      color: #E6AB02 !important;
      font-size: 26px;
      font-weight: 600;
      text-decoration: none !important;
      transition: transform .2s !important; 
    }

    .selected-nav-option:hover {
      transform: scale(1.04) !important;
    }
    .award-nav-option {
      width: 80px;
      height: 80px;
      border-radius: 40px;
    }

    #award-filter {
      font-size: 20px;
      padding-right: 70px;
    }

    body {
      font-family: 'Didact Gothic', sans-serif; 
    }
  </style>
</head>
<body>
  <div class="row">
    <div class="col-sm-12">
      <div id="header" class="d-flex justify-content-between">
        <div class="nav-options">
          <a class="selected-nav-option" href="">awards</a>
          <a href="reception.html" class="nav-option">reception</a>
          <a href="sources.html" class="nav-option">credits</a>
          <a href="index.html" class="nav-option">back to home</a>
        </div>
        <div id="filters" class="d-flex">
          <div class="d-flex" id="award-filter">
            <div class="text-center p-1 mx-2">
              <a href="oscars.html" class="mx-1 btn btn-outline-light award-nav-option"><img class="mt-2" src="./images/oscar_man.png"/ width="45px" height="45px"></a>
              <br/>
              oscars
            </div>
            <div class="text-center p-1 mx-2">
              <a href="screenguild.html" class="mx-1 btn btn-light award-nav-option"><img class="mt-3" src="./images/trophy.png"/ width="35px" height="35px"></a>
              <br/>
              screen <br/>actors guild
            </div>
            <div class="text-center p-1 mx-2">
              <a href="goldenglobes.html"  class="mx-1 btn btn-outline-light award-nav-option"><img class="mt-2" src="./images/golden_globe_icon.png"/ width="40px" height="40px"></a>
              <br/>
              golden <br/> globes
            </div>
          </div>
          <!-- slider -->
          <div>
            <div id="slider-section">
              <div id="range-label">1994 - 2019</div>
              <div id="slider-container"></div>
            </div>
            <!-- category selection -->
            <div class="text-center pt-3">
              <button type="button" id="all-btn" class="mx-1 btn btn-light">all</button>
              <button type="button" name="MALE ACTOR IN A LEADING ROLE" id="actor-btn" class="mx-1 btn btn-outline-light">best actor</button>
              <button type="button" name="FEMALE ACTOR IN A LEADING ROLE" id="actress-btn" class="mx-1 btn btn-outline-light">best actress</button>
              <button type="button" name="MALE ACTOR IN A SUPPORTING ROLE" id="sup-actor-btn" class="mx-1 btn btn-outline-light">best supporting actor</button>
              <button type="button" name="FEMALE ACTOR IN A SUPPORTING ROLE" id="sup-actress-btn" class="mx-1 btn btn-outline-light">best supporting actress</button>
            </div>
          </div>
        </div>
       </div>
      <div class="main-caption">
        <h3 class="font-weight-bold">Individual nominees and winners for the main categories</h3>
        <h4>Explore the racial and ethnic diversity of nominees and winners for the Screen Actors Guild Awards. Adjust the filters above to change the years and categories, and hover over each datapoint to view more information about the individual.</h4> 
      </div>
      <!-- first graph -->
      <div id="main-1">
        <div id="graph"></div>
        <div id="legend">
          <div id="zoom"> &#8678; Scroll to Zoom</div>
        </div>
      </div>
      <div>
        <h4 class="main-caption p-3 text-center">
          Based on the current selections, from <a id="year_start"></a> to <a id="year_end"></a>, the race breakdown is as follows:
        </h4>
        <div class="d-flex flex-row justify-content-between text-center" style="color:white; width: 20%; margin: auto">
          <div>
            <a id="white_nominees" style="font-size: 40px"></a><br> white nominees<br>(excluding winners)
          </div>
          <div>
            <a id="white_winners" style="font-size: 40px"></a><br>white winners
          </div>
        </div>
      </div>
    </div>
  </div>
  <h2 style="padding-left: 40px;text-align: left; margin-top: 300px; font-size:2.0rem">
    Percentage of racial minorities by award category for the Screen Actor's Guild.
  </h2>
  <h4 class="main-caption p-3 text-left" style="margin: 50px;">
    The following graphs explore minority representation across different award categories. 
    Although people of color have remained underrepresented in every category of employment in the film industry, different roles also present unique challenges. 
    As of 2020, 3 out of 10 lead actors in film are people of color, while only 1.5 out of 10 directors are people of color. 
    A higher minority representation in nominees does not always translate to same representation in winners. 
    For viewing purposes, the graphs below show the rolling 5-year average of the percentage of minorities.<br><br>
  
    <span style = "color: #DCBE7B; opacity: 1.0;"> Toggle the year range using the top bar. <br><br>
    Individuals to include: <select id="selectButton"></select> </span>
  </h4>
  <div class="row" style='margin: 50px;'>
    <div class="col-sm-12" style="color:white">
      <div id="summary_graph"></div>
      <div id="summary_legend"></div>
    </div>
  </div>
  <h2 style="padding-left: 40px;text-align: left; margin-top: 300px; font-size:2.0rem">
    Percentage of racial minorities by award show.
  </h2>
  <h4 class="main-caption p-3 text-left" style="margin: 50px;">
    We can also compare minority representation at the Screen Actor's Guild to the other two award shows. <br><br>
    <span style = "color: #DCBE7B; opacity: 1.0;">
      Use the top bar to adjust the date range and categories included.
      </span>
  </h4>
  <div class="row" style='margin: 50px;'>
    
    <div class="col-sm-12" style="color:white">
      <div id="compare_graph"></div>
      <div id="compare_legend"></div>
    </div>
  </div>

<!-- JAVASCRIPT -->
<script>
    var actorCategory = "MALE ACTOR IN A LEADING ROLE"
    var actressCategory = "FEMALE ACTOR IN A LEADING ROLE"
    var actorSupCategory = "MALE ACTOR IN A SUPPORTING ROLE"
    var actressSupCategory = "FEMALE ACTOR IN A SUPPORTING ROLE"
    var svgWidth = 1200
    var svgHeight = 800
    var legendWidth = 400
    var width = 1200
    var height = 800
    var summaryWidth = document.getElementById('summary_graph').clientWidth;
    var summaryHeight = Math.floor(summaryWidth*0.25*0.7);
    var margins = {top: 10, right: 10, bottom: 20, left: 30};

    var graphsvg = d3.select("#graph")
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight);

    function zoomed(scale) {
        graphgElem.attr("transform", d3.event.transform)
    }

    var zoom = d3.zoom().on("zoom", zoomed);
    var graphgElem = graphsvg
        .append("g")
        .classed("graph-g", true)
        .call(zoom)
        .append("g")
    graphgElem.append("rect")
        .attr("x", -10000)
        .attr("y", -10000)
        .style("fill", "#1d1c1c")
        .attr("height", 20000)
        .attr("width", 20000)
    var myimage = graphgElem.append('image')
        .attr('xlink:href', './images/trophy.png')
        .attr('width', 150)
        .attr('height', 150)
        .attr('opacity', 0.4)
        .attr('x', width / 2 + 1040)
        .attr('y', height / 2 + 655)
        .attr('transform', 'scale(0.35)')

    var legendsvg = d3.select("#legend")
        .append("svg")
        .attr("width", legendWidth)
        .attr("height", svgHeight - 300)
        .attr("transform", "translate(0, 200)"); // pushes viz to right + up
    legendsvg.append("g");

    // Define the div for the tooltip
    var tooltipDiv = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

    var compare_svg = d3.select("#compare_graph")
        .append("svg")
        .attr("width", summaryWidth)
        .attr("height", summaryHeight)        
        .append("g")
        .attr("transform", "translate(" + margins.left + "," + margins.top + ")");

    var compare_legendsvg = d3.select("#compare_legend")
        .append("svg")
        .attr("width", summaryWidth)
        .attr("height", 500)
    compare_legendsvg.append("g");

        // format dropdown button for graph 1
    var includes = ["all", "winner", "nominee"] // button options
    var includes_text = {"all": "all nominees", 
                        "winner": "winners only", 
                        "nominee": "nominees excluding winners"}
    d3.select("#selectButton")
      .selectAll('myOptions')
     	.data(includes)
      .enter()
    	.append('option')
      .text(function (d) { return includes_text[d]; }) // map to the right display text
      .attr("value", function (d) { return d; }) // corresponding value returned by the button

    function update(data, startYear, endYear, categories) {
        // first, filter data to year range
        let filteredData = data.filter(d => d.year_ceremony >= startYear && d.year_ceremony <= endYear && categories.includes(d.category))

        // console.log("filteredData", filteredData)
        var winnerDataByCategory = categories.reduce(function(map, category) {
            map[category] = filteredData.filter(d => d.category == category && d.winner == "TRUE");
            return map;
        }, {})

        var nomineeDataByCategory = categories.reduce(function(map, category) {
            map[category] = filteredData.filter(d => d.category == category && d.winner == "FALSE");
            return map;
        }, {})

        var numWinners = categories.length * (endYear - startYear + 1)

        // POPULATING STATS PANEL
        var white_nominees = filteredData.filter(d => d.fixed_race == "white" && d.winner == "FALSE").length / filteredData.filter(d => d.winner == "FALSE").length;
        var white_winners = filteredData.filter(d => d.fixed_race == "white" && d.winner == "TRUE").length / filteredData.filter(d => d.winner == "TRUE").length;

        var percent_format = new Intl.NumberFormat("en-US", {
            style: 'percent',
            maximumFractionDigits: 0,
        });

        white_nominees_pct = d3.select("#white_nominees").text(percent_format.format(white_nominees));
        white_winners_pct = d3.select("#white_winners").text(percent_format.format(white_winners));
        year_start = d3.select("#year_start").text(startYear)
        year_end = d3.select("#year_end").text(endYear)
        // we position the nominees in a 1 layer ring, and the physics
        // simulation will take care of repelling the overlaps
        let nomineeRadius = Math.min(295, Math.max(Math.pow(numWinners*400, 0.51), 155))
        let winnerRadius = Math.max(Math.sqrt(numWinners * 60), 60)

        // DRAW CIRCLES AROUND NOMINEES AND WINNERS
        var winnerCircleNode = graphgElem
            .selectAll(".winner-circle")
            .data([winnerRadius, nomineeRadius])
        winnerCircleNode.join(
            enter => enter.append("circle")
                .classed("winner-circle", true)
                .attr("cx", width / 2)
                .attr("cy", height / 2)
                .attr("r", winnerRadius * 1.3)
                .style("fill", "#A7771C")
                .style("stroke","#b8a22a")
                .style("stroke-width", 8)
                .style("opacity", .1),
            update => update.transition()
                .duration(300)
                .attr("r", (d, i) => {
                    if (i == 0) return 1.3 * d;
                    return 1.25 * d;
                }),
            exit => exit.remove()
        )

        // CALCULATE POSITION OF DOTS

        // separate sectors by 36 degrees
        var sectorSeparation = 2 * Math.PI / 12.0;
        // the arc angle of each sector
        let arcAngle = (2 * Math.PI - categories.length * sectorSeparation) / categories.length
        if (categories.length == 1) {
            arcAngle = 2 * Math.PI
        }
        // offset angle to maintain vertical symmetry of the graph
        var offsetAngle = sectorSeparation + arcAngle / 2 - Math.PI / 2;

        var nomineeCounter = categories.reduce(function(map, category) {
            map[category] = 0;
            return map;
        }, {})

        var winnerCounter = categories.reduce(function(map, category) {
            map[category] = 0;
            return map;
        }, {})
        for (let i = 0; i < data.length; i++) {
            if (data[i].year_ceremony < startYear || data[i].year_ceremony > endYear || !categories.includes(data[i].category)) {
                continue
            }

            // if we're looking at a nominee
            if (data[i].winner === "FALSE") {
                // calculate angle of the dot
                let theta = offsetAngle + (sectorSeparation + arcAngle) * categories.indexOf(data[i].category) + arcAngle * (nomineeCounter[data[i].category] / nomineeDataByCategory[data[i].category].length) + (arcAngle / nomineeDataByCategory[data[i].category].length) / 2
                data[i].x = nomineeRadius * Math.cos(theta) + width / 2;
                data[i].y = nomineeRadius * Math.sin(theta) + height / 2;
                data[i].level = "Nominee"
                nomineeCounter[data[i].category] += 1
            } else {
                var theta = offsetAngle + (sectorSeparation + arcAngle) * categories.indexOf(data[i].category) + arcAngle * (winnerCounter[data[i].category] / winnerDataByCategory[data[i].category].length) + (arcAngle / winnerDataByCategory[data[i].category].length) / 2
                if (winnerDataByCategory[data[i].category].length == 1) {
                    theta = offsetAngle + (sectorSeparation + arcAngle) * categories.indexOf(data[i].category) + arcAngle / 2
                }
                data[i].x = winnerRadius * Math.cos(theta) + width / 2;
                data[i].y = winnerRadius * Math.sin(theta) + height / 2;
                data[i].level = "Winner"
                // console.log(data[i].x, data[i].y)
                winnerCounter[data[i].category] += 1
            }
        }

        // // CREATE CATEGORY LABEL ARCS
        var arcRadius = nomineeRadius * 1.25 + 17
        function arcGenerator(index) {
            var startAngle = categories.length === 1 ? arcAngle / 2 : index * (arcAngle + sectorSeparation) + offsetAngle - 0.041 * Math.PI
            var endAngle = categories.length === 1 ? arcAngle : startAngle + arcAngle + Math.PI / 11.0
            let sweep = 1
            let radius = arcRadius
            if (startAngle > -0.3 && endAngle < Math.PI + 0.3) {
                let temp = endAngle
                endAngle = startAngle
                startAngle = temp
                sweep = 0
                radius += 15
            }
            let startX = Math.cos(startAngle) * radius + width / 2
            let startY = Math.sin(startAngle) * radius + height / 2
            let endX = Math.cos(endAngle) * radius + width / 2
            let endY = Math.sin(endAngle) * radius + height / 2
            return "M " + startX + "," +  startY + " A " + radius + "," + radius + " 0 0," + sweep + " " + endX + "," + endY;
        }
        function categoryName(name) {
            switch(name) {
                case "MALE ACTOR IN A LEADING ROLE": return "best actor"
                case "FEMALE ACTOR IN A LEADING ROLE": return "best actress"
                case "MALE ACTOR IN A SUPPORTING ROLE": return "best supporting actor"
                case "FEMALE ACTOR IN A SUPPORTING ROLE": return "best supporting actress"
                    return ""
            }
        }
        function categoryID(name) {
            switch(name) {
                case "MALE ACTOR IN A LEADING ROLE": return 1
                case "FEMALE ACTOR IN A LEADING ROLE": return 2
                case "MALE ACTOR IN A SUPPORTING ROLE": return 3
                case "FEMALE ACTOR IN A SUPPORTING ROLE": return 4
                    return ""
            }
        }
        graphgElem.selectAll(".arc-path").remove()
        var categoryLabels = graphgElem.selectAll(".category-arc-labels")
            .data(categories, d=>categoryID(d))
        categoryLabels.join(
            enter => enter.append("path")
                .classed("arc-path", true)
                .attr("id", d => "arcpath-" + d) //Unique id of the path
                .attr("d", (d,i) => arcGenerator(i)) //SVG path
                .style("stroke", "none")
                .style("fill", "none")
                .each(function(d){ this._current = d; }),
            update => update.attr("d", (d,i) => arcGenerator(i)),
            exit => exit.remove()
        )
        categoryLabels.enter().append("text")
            .style('fill', 'white')
            .style("font-size", "20px")
            .append("textPath") //append a textPath to the text element
            .attr("xlink:href", d => "#arcpath-" + d) //place the ID of the path here
            .style("text-anchor","middle") //place the text halfway on the arc
            .attr("startOffset", "50%")
            .text(d => categoryName(d));

        // ZOOM TO FIT THE DOTS
        var resetScale = 300 / nomineeRadius
        d3.select('.graph-g')
            .transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity);

        // default color scale
        // color = d3.scaleOrdinal(d3.schemeCategory10).domain(data.map(d => d.fixed_race));
        // customized color scale
        color = d3.scaleOrdinal()
            .domain(['white', 'black', 'hispanic', 'asian', 'other'])
            .range(['#E6AB02', '#67A51F', '#7570B2', '#E7298A', '#D95F03'])
        var node = graphgElem
            .selectAll(".graph-circle")
            .data(data, d => d.id);
        node.join(
            enter => enter.append("circle")
                .attr("class", function(d){return "graph-circle " + d.fixed_race + " " + d.winner})
                .attr("r", 2)
                .attr("cx", width / 2)
                .attr("cy", height / 2)
                .style("fill", d => color(d.fixed_race))
                .style("opacity", 1)
                .attr("stroke", d => color(d.fixed_race))
                .style("stroke-width", 0.5)
                .on("mouseover", function(d) {
                    d3.select(this).style("stroke", "white")
                    tooltipDiv.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltipDiv	.html("Name: " + d.name + "<br>Film: " + d.film + "<br>Year: " + d.year_ceremony)
                        .style("left", (d3.event.pageX + 10) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    d3.select(this).style("stroke", color(d.fixed_race))
                    tooltipDiv.transition()
                        .duration(500)
                        .style("opacity", 0);
                }),
            update => update.attr("r", d => {
                // if the datapoint is within range, it has a radius of 2. otherwise, we hide it with radius 0
                if (d.year_ceremony >= startYear && d.year_ceremony <= endYear && categories.includes(d.category)) {
                    return 2
                }
                return 0
            }),
            exit => exit.remove()
        )
    }

    d3.csv("./datasets/sag_merged.csv").then((csv_orig) => {
      d3.csv('./datasets/all_awards_race_year_count_latest.csv').then((all_data) => {
        csv_data = []
        for (var i = 0; i < csv_orig.length; i++) {
            csv_orig[i].fixed_race = csv_orig[i].race.toLowerCase();
            if (csv_orig[i].fixed_race == 'asian/indian') {csv_orig[i].fixed_race = "asian"}

            else if (csv_orig[i].fixed_race == 'middle eastern') {csv_orig[i].fixed_race = "white"}

            if (!(csv_orig[i].fixed_race == 'asian' || csv_orig[i].fixed_race == 'white' || csv_orig[i].fixed_race == 'black' ||
            csv_orig[i].fixed_race == 'hispanic')) {
                csv_orig[i].fixed_race = "other";
            }

            csv_orig[i].id = i;
            csv_orig[i].year_ceremony = parseInt(csv_orig[i].year_ceremony.split("-")[0].trim());

            const category = csv_orig[i].category.trim();
            var includedCategory = false;
            if (category === "FEMALE LEAD ROLE" || category === "FEMALE LEAD" || category === "FEMALE LEAD IN A MOTION PICTURE" ||
                category === "FEMALE ACTOR IN A LEADING ROLE") {
                csv_orig[i].category = "FEMALE ACTOR IN A LEADING ROLE"
                includedCategory = true;
            }
            if (category === "MALE LEAD ROLE" || category === "MALE LEAD" || category === "MALE LEAD IN A MOTION PICTURE" ||
                category === "MALE ACTOR IN A LEADING ROLE") {
                csv_orig[i].category = "MALE ACTOR IN A LEADING ROLE"
                includedCategory = true;
            }
            if (category === "FEMALE SUPPORTING ROLE" || category === "FEMALE SUPPORT" || category === "FEMALE SUPPORT IN A MOTION PICTURE" ||
                category === "FEMALE ACTOR IN A SUPPORTING ROLE") {
                csv_orig[i].category = "FEMALE ACTOR IN A SUPPORTING ROLE"
                includedCategory = true;
            }
            if (category === "MALE ACTOR IN A SUPPORTING ROLE" || category === "MALE SUPPORTING ROLE" || category === "MALE SUPPORT" ||
                category === "MALE SUPPORT IN A MOTION PICTURE") {
                csv_orig[i].category = "MALE ACTOR IN A SUPPORTING ROLE"
                includedCategory = true;
            }

            if (includedCategory) {
                csv_data.push(csv_orig[i]);
            }

        }

        function getData(startYear, endYear) {
            var data = []
            for (var i = 0; i < csv_data.length; i++) {
                // push all datapoints, both nominees and winners
                var year = csv_data[i].year_ceremony;
                if (year >= startYear && year <= endYear) {
                    data.push(csv_data[i]);
                }
            }
            return data;
        }

        // default color scale
        // color = d3.scaleOrdinal(d3.schemeCategory10).domain(data.map(d => d.fixed_race));
        // customized color scale
        color = d3.scaleOrdinal()
            .domain(['white', 'black', 'hispanic', 'asian', 'other'])
            .range(['#E6AB02', '#67A51F', '#7570B2', '#E7298A', '#D95F03'])
        // 1: LEGEND using D3-LEGEND (https://d3-legend.susielu.com/)
        // svg.append("g")
        //   .attr("class", "legend")
        //   .attr("transform", "translate(1000, 200)");

        // var legendOrdinal = d3.legendColor()
        //   .shape("path", d3.symbol().type(d3.symbolCircle).size(150)())
        //   .shapePadding(10)
        //   .scale(color)

        // svg.select(".legend")
        //   .call(legendOrdinal);
        // svg.selectAll(".legend")
        //     .style("background-color", "white");
        // });

        // 2: LEGEND using manual method
        // create list of keys
        var keysSet = new Set(csv_data.map(d => d.fixed_race))
        var keys = Array.from(keysSet)

        // Add one dot in the legend for each name.
        legendsvg.selectAll('legendDots')
            .data(keys)
            .enter()
            .append("circle")
            .on("mouseover", function(d) {
                d3.select(".label-" + d).style("font-weight", 900).style("text-decoration", "underline");
                // console.log(d);
                for (var i = 0; i < keys.length; i++) {
                    if (keys[i] !== d) {
                        graphsvg.selectAll("." + keys[i]).style("opacity", 0.1)
                    }
                }
            })
            .on("mouseout", function(d) {
                d3.select(".label-" + d).style("font-weight", 300).style("text-decoration", "none");
                for (var i = 0; i < keys.length; i++) {
                    if (keys[i] !== d) {
                        graphsvg.selectAll("." + keys[i]).style("opacity", 1)
                    }
                }
            })
            .attr("cx", 100)
            .attr("cy", function(d,i){ return (i+1)*25}) // 100 is where the first dot appears. 25 is the distance between dots
            .attr("r", 7)
            .style("fill", function(d){ return color(d)})


        // Add one dot in the legend for each name.
        legendsvg.selectAll('legendLabels')
            .data(keys)
            .enter()
            .append("text")
            .attr("class", function(d){ return "label-" + d })
            .attr("x", 120)
            .attr("y", function(d,i){ return (i+1)*25}) // 100 is where the first dot appears. 25 is the distance between dots
            // .style("fill", function(d){ return color(d)})
            .text(function(d){ return d})
            .attr("text-anchor", "left")
            .style("alignment-baseline", "middle")
            .style("fill", "#b8b8b8")
            .style("font-family", "Didact Gothic")
            .style("font-size", "18px")
            .style("text-transform", "lowercase")
            .on("mouseover", function(d) {
                d3.select(this).style("font-weight", 900).style("text-decoration", "underline").style("cursor","default");
                for (var i = 0; i < keys.length; i++) {
                    if (keys[i] !== d) {
                        graphsvg.selectAll("." + keys[i]).style("opacity", 0.3)
                    }
                }
            })
            .on("mouseout", function(d) {
                d3.select(this).style("font-weight", 300).style("text-decoration", "none");
                for (var i = 0; i < keys.length; i++) {
                    if (keys[i] !== d) {
                        graphsvg.selectAll("." + keys[i]).style("opacity", 1)
                    }
                }
            });
        var legendCircleLabels = [{y: 300, text: "Winners"}, {y: 270, text: "Nominees"}]
        legendsvg.selectAll('legendCircleLines')
            .data(legendCircleLabels)
            .enter()
            .append('line')
            .style("stroke", "#F8F9FA")
            .style("stroke-width", 2)
            .attr("x1", 120)
            .attr("y1", d => d.y)
            .attr("x2", 180)
            .attr("y2", d => d.y);

        legendsvg.selectAll('legendCircleLines')
            .data(legendCircleLabels)
            .enter()
            .append('text')
            .attr("x", 190)
            .attr("y", d => d.y) // 100 is where the first dot appears. 25 is the distance between dots
            .text(d => d.text)
            .attr("text-anchor", "left")
            .style("alignment-baseline", "middle")
            .style("fill", "#b8b8b8")
            .style("font-family", "Didact Gothic")
            .style("font-size", "18px")
            .style("text-transform", "lowercase")
            .attr("class", function(d){return "label-" + d.text} )
            .on("mouseover", function(d) {
                d3.select(this).style("font-weight", 900).style("text-decoration", "underline").style("cursor","default");
                if (d == legendCircleLabels[0]) {
                    graphsvg.selectAll(".FALSE").style("opacity", 0.3)
                }
                else {
                    graphsvg.selectAll(".TRUE").style("opacity", 0.3)
                }

            })
            .on("mouseout", function(d) {
                graphsvg.selectAll(".TRUE, .FALSE").style("opacity", 1)
                d3.select(this).style("font-weight", 300).style("text-decoration", "none");
            });


        // legend for the winner / nominee circles
        var legendCircleRadii = [50,20]

        legendsvg.selectAll('legendCircles')
            .data(legendCircleRadii)
            .enter()
            .append("circle")
            .attr("cx", 120)
            .attr("cy", 300)
            .attr("r", d => d)
            .attr("fill", "#b8a22a")
            .style("stroke","#b8a22a")
            .style("stroke-width", 8)
            .attr("opacity", .2)
            .on("mouseover", function(d) {
                if (d == legendCircleRadii[0]) {
                    graphsvg.selectAll(".TRUE").style("opacity", 0.3)
                    d3.select(".label-" + legendCircleLabels[1].text).style("font-weight", 900).style("text-decoration", "underline").style("cursor","default");
                }
                else {
                    graphsvg.selectAll(".FALSE").style("opacity", 0.3)
                    d3.select(".label-" + legendCircleLabels[0].text).style("font-weight", 900).style("text-decoration", "underline").style("cursor","default");
                }

            })
            .on("mouseout", function(d) {
                graphsvg.selectAll(".TRUE, .FALSE").style("opacity", 1)
                d3.select(".label-" + legendCircleLabels[0].text).style("font-weight", 300).style("text-decoration", "none");
                d3.select(".label-" + legendCircleLabels[1].text).style("font-weight", 300).style("text-decoration", "none");
            });
        // draw the lines that label the winner and nominee legend circles


        let categories = [actorCategory, actressCategory, actorSupCategory, actressSupCategory]
        update(csv_data, 1993, 2019, categories);

        var node = graphgElem.selectAll(".graph-circle")

        var winnerData = csv_data.filter(d => d.winner === "TRUE");
        var simulationCircle = d3.forceSimulation()
            .force("center", d3.forceCenter().x(width / 2).y(height / 2)) // Attraction to the center of the svg area
            .force("charge", d3.forceManyBody().strength(0)) // Nodes are attracted one each other of value is > 0
            .force("collide", d3.forceCollide().strength(0.2).radius(5).iterations(1)) // Force that avoids circle overlapping

        simulationCircle
            .nodes(winnerData)
            .on("tick", function(d){
                node
                    .attr("cx", function(d){ return d.x; })
                    .attr("cy", function(d){ return d.y; })
            });

        var nomineeData = csv_data.filter(d => d.winner === "FALSE");
        var simulationRing = d3.forceSimulation()
            .force("center", d3.forceCenter().x(width / 2).y(height / 2)) // Attraction to the center of the svg area
            .force("charge", d3.forceManyBody().strength(0)) // Nodes are attracted one each other of value is > 0
            .force("collide", d3.forceCollide().strength(0.2).radius(5).iterations(1)) // Force that avoids circle overlapping

        simulationRing
            .nodes(nomineeData)
            .on("tick", function(d){
                node
                    .attr("cx", function(d){ return d.x; })
                    .attr("cy", function(d){ return d.y; })
            });
        
        // SUMMARY GRAPH
      year_race_counts = {} // counts number per year, race, category
        
      var races = ['white', 'black', 'hispanic', 'asian', 'other']
        for (var i=1993; i<=2020; i++){
          year_race_counts[i] = {"all":{}}
          for (var j=0; j<races.length; j++){
            year_race_counts[i][races[j]] = {};
            for (var k=0; k<categories.length; k++){
              year_race_counts[i]["all"][categories[k]] = {"winner": 0, "nominee": 0, "all": 0};
              year_race_counts[i][races[j]][categories[k]] = {"winner": 0, "nominee": 0, "all": 0};
            }
          }
        }

      csv_data.forEach( function(d) {
        var year = +d.year_ceremony;
        var fixed_race = d.fixed_race;
        var category = d.category;
        var winner = d.winner;
        
        if (year_race_counts[year][fixed_race][category] === undefined){
          year_race_counts[year][fixed_race][category] = {"winner": 0, "nominee": 0, "all": 0};
        } else if (winner=="TRUE") {
          year_race_counts[year][fixed_race][category]["all"] ++;
          year_race_counts[year]["all"][category]["all"]++;
          year_race_counts[year][fixed_race][category]["winner"] ++;
          year_race_counts[year]["all"][category]["winner"]++;
        } else {
          year_race_counts[year][fixed_race][category]["all"] ++;
          year_race_counts[year]["all"][category]["all"]++;
          year_race_counts[year][fixed_race][category]["nominee"] ++;
          year_race_counts[year]["all"][category]["nominee"]++;
        }
      });

      var race_counts = []
      for (var yr=1993; yr<=2020; yr++){
        for (var c=0; c<categories.length; c++){
          if (year_race_counts[yr]["all"][categories[c]]["all"] == 0) {
            for (var i=0; i<includes.length; i++){
              race_counts.push({"year":yr, "category": categories[c], "pct":0, "include": includes[i]})
            }
          }
          else {
            for (var i=0; i<includes.length; i++){
              // pct_white is actually percent minority now
              var pct_white = 1-year_race_counts[yr]["white"][categories[c]][includes[i]] / year_race_counts[yr]["all"][categories[c]][includes[i]]
              var datapt = {"year":yr, "category": categories[c], "pct":pct_white, "include": includes[i]}
              race_counts.push(datapt);
            }
          }
        }
      }

      var race_counts_rolling = []
      for (var yr=1993; yr<=2020; yr++){
        var min_yr = Math.max(1993, yr-2)
        var max_yr = Math.min(2020, yr+2)
        
        for (var c=0; c<categories.length; c++){
          for (var i=0; i<includes.length; i++) {
            var rolling_data = race_counts.filter(d => (d.category == categories[c]) && (d.year >= min_yr) && (d.year <= max_yr) && (d.include == includes[i]))
            var mean = d3.mean(rolling_data.map(d => d.pct))*100
            datapt = {"year":yr, "category": categories[c], "pct":mean, "include": includes[i]}
            race_counts_rolling.push(datapt)
          }
        }
      }

      var current_race_counts_rolling = race_counts_rolling.filter(d => (d.include == "all") )

      var race_counts_rolling_nested = d3.nest()
          .key(function(d) { return d.category; })
          .entries(current_race_counts_rolling);

      var summaryWidth_subplot = Math.floor((summaryWidth-margins.left-margins.right)/categories.length); 
      var summaryHeight_subplot = summaryHeight;

      // dimensions of each subplot, after subtracting margins
      var summary_height = summaryHeight_subplot - margins.top - margins.bottom
      var summary_width = summaryWidth_subplot - margins.left - margins.right

      var summary_x = d3.scaleLinear().range([0, summary_width]).domain([1993, 2019]);

      var summary_y = d3.scaleLinear().range([summary_height, margins.top])
          summary_y.domain([0, Math.min(100, 1.3*d3.max(race_counts_rolling, function(d) { return d.pct; })+0.2)]);

      var summary_line = d3.line()
        .x(function(d) {return summary_x(d.year);})
        .y(function(d) {return summary_y(d.pct);});


      var summary_svg = d3.select("#summary_graph").selectAll("svg")
        .data(race_counts_rolling_nested)
        .enter()
        .append("svg")
        .attr("class", "categoryChart")
        .attr("height", summaryHeight_subplot)
        .attr("width", summaryWidth_subplot)
        .append("g")
        .attr("transform", "translate(" + margins.left + "," + margins.top + ")")

      summary_xAxis = summary_svg.append("g")
        .attr("class", "xaxis")
        .attr("transform", "translate(0," + summary_height + ")")
        .call(d3.axisBottom(summary_x).ticks(3).tickFormat(d3.format("d")));

      summary_yAxis = summary_svg.append("g").attr("class", "yaxis").call(d3.axisLeft(summary_y).ticks(5));

      summary_svg.append("path")
                .attr("class", "line") 
                .attr("fill", "none")
                .attr("stroke", "#AB8D3F")
                .attr("stroke-width", 1.9)
                .attr("d", function(d){
                  return summary_line(d.values)
                })
      
      summary_svg.append("text") // Title text
            .attr("x", (summary_width / 2))             
            .attr("y", margins.top+2)
            .attr("text-anchor", "middle")  
            .style("font-size", "20px")   
            .style("fill", "white")
            .text(function(d){ return(d.key)});

      // Mouseover Tooltip, based on Mike's example here: https://bl.ocks.org/mbostock/3902569
      var focus = summary_svg.append("g")
              .attr("class", "focus")
              .style("display", "none");

          focus.append("circle")
              .attr("fill", "none")
              .attr("stroke", "white")
              .attr("r", 3);

          focus.append("text")
                .attr("x", 0)
                .attr("dy", "-1.20em")
                .style("font-size","14px")
                .style("fill", "white")
                .style("text-anchor", "middle");

          summary_svg.append("rect")
              .attr("class", "overlay")
              .attr("width", summary_width)
              .attr("height", summary_height)
              .style("fill-opacity", 0.0)
              .on("mouseover", function() { focus.style("display", null); })
              .on("mouseout", function() { focus.style("display", "none"); })
              .on("mousemove", summary_mousemove);

          var bisectYear = d3.bisector(function(d) {
            return d.year;
          }).left;

          function summary_mousemove() {
              var year, index, index_diff;
              year = summary_x.invert(d3.mouse(this)[0]);
              var focus = summary_svg.selectAll(".focus");
              focus.attr("transform", function(d) {

                index = bisectYear(d.values, year, 0, d.values.length - 1);
                var yDomain = d3.extent(d.values, function(d) { return d.pct; });
                
                focus.selectAll("text")
                  .text(function (d){return (d.values[index].pct.toFixed(1) + " %")})
                  .attr("fill", "white");
                // adjust mouseover to use appropriate scale
                return "translate(" + summary_x(d.values[index].year) + "," + summary_y(d.values[index].pct) + ")"
                  });
          };

        // COMPARE BETWEEN AWARDS
              
        var line_height = summaryHeight - margins.top - margins.bottom
        var line_width = summaryWidth - margins.left - margins.right

        var compare_x = d3.scaleLinear().range([0, line_width]).domain([1993, 2019]);

        var compare_y = d3.scaleLinear()
            .range([line_height, margins.top])
            compare_y.domain([0, Math.min(100, d3.max(all_data, function(d) { return d.pct_race * 100; }))]);;

        var compare_line = d3.line()
          .x(function(d) {return compare_x(d.year_ceremony);})
          .y(function(d) {return compare_y(d.pct_race * 100);});

        var line_color = d3.scaleOrdinal(['oscars','golden globes', 'sag'] ,['#1f77b4', '#ff7f0e', '#2ca02c']);

        var awards = ['sag', 'oscars','golden globes']
        var categoryMappings = {"Actor In A Leading Role": "MALE ACTOR IN A LEADING ROLE",
          "Actress In A Leading Role": "FEMALE ACTOR IN A LEADING ROLE", "Supporting Actor In A Leading Role":
                  "MALE ACTOR IN A SUPPORTING ROLE","Supporting Actress In A Leading Role": "FEMALE ACTOR IN A SUPPORTING ROLE"}


        let filteredData = all_data.filter(d => (categories.includes(categoryMappings[d.category])) && (d.fixed_race==='white'))
        let combinedData = []
        let element = {}
        filteredData.forEach( function(d) {
          if (d.award + "_" + d.year_ceremony in element) {
            element[d.award + "_" + d.year_ceremony] += (1 - d.pct_race) / categories.length
          }

          else {
            element[d.award + "_" + d.year_ceremony] = (1 - d.pct_race) / categories.length;
          }
        });

        var increments = [-2, -1, 1, 2];
        for (var key in element) {
          var count = 1;
          var sum = element[key];
          for (const inc of increments) {
            var year_ceremony = parseInt(key.split("_")[1]) + inc;
            var award = key.split("_")[0];
            var key2 = award + "_" + year_ceremony;
            if (key2 in element) {
              sum += element[key2];
              count += 1;
            }
          }
          element[key] = sum / count;
        }

        for (var key in element) {
          let award = key.split("_")[0];
          let year_ceremony = key.split("_")[1];
          combinedData.push({"award": award, "year_ceremony": year_ceremony, "pct_race": element[key]})
        }

        for (var i=0; i<awards.length; i++){
          compare_svg.append("path")
            .datum(combinedData.filter(d => (d.award === awards[i])))
            .attr("class", "line") 
            .attr("id", awards[i].concat("Line"))
            .attr("d", compare_line)
            .attr("active", 0)
            .style("fill", "none")
            .style("stroke", line_color(awards[i]))
            .style("stroke-width", function(d) {
              if (awards[i] === "sag") {
                return "3";
              }
              else {
                return "1";
              }})
        }

        var compare_xAxis = compare_svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0," + line_height + ")")
            .call(d3.axisBottom(compare_x).tickFormat(d3.format("d")));
        
        var compare_yAxis = compare_svg.append("g")
          .attr("class", "axis")
          .attr("transform", "translate(0,0)")
          .call(d3.axisLeft(compare_y));

        
        compare_legendsvg.selectAll('legendDots')
          .data(awards)
          .enter()
          .append("circle")
          .attr("cx", 40)
            .attr("cy", function(d,i){ return (i+1)*25}) // 100 is where the first dot appears. 25 is the distance between dots
            .attr("r", 4)
            .style("fill", function(d){ return line_color(d)})

        compare_legendsvg.selectAll('legendLabels')
          .data(awards)
          .enter()
          .append("text")
            .attr("class", function(d){ return "label-" + d })
            .attr("x", 50)
            .attr("y", function(d,i){ return (i+1)*25}) // 100 is where the first dot appears. 25 is the distance between dots
            // .style("fill", function(d){ return color(d)})
            .text(function(d){ return d})
            .attr("text-anchor", "left")
            .style("alignment-baseline", "middle")
            .style("fill", "#b8b8b8")
            .style("font-family", "Didact Gothic")
            .style("font-size", "18px")
            .style("text-transform", "lowercase")

        // SLIDER LOGIC
        var slider = createD3RangeSlider(1994, 2020, "#slider-container");

        slider.onChange(function(newRange){
            d3.select("#range-label").text(newRange.begin + " - " + newRange.end);
            var newData = getData(newRange.begin, newRange.end);

            // Update summary graph
            var new_race_counts = current_race_counts_rolling.filter(d => (d.year > newRange.begin) && (d.year < newRange.end))
            race_counts_rolling_nested = d3.nest()
              .key(function(d) { return d.category; })
              .entries(new_race_counts);

            summary_update = d3.select("#summary_graph").selectAll("svg").data(race_counts_rolling_nested);
            var new_lines = summary_update.enter()
                        .append("svg")
                        .attr("class", "categoryChart")
                        .attr("height", summaryHeight_subplot)
                        .attr("width", summaryWidth_subplot)
                        .append("g")
                      .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                        
            summary_update.exit().remove()
            
            summary_x.domain([newRange.begin, newRange.end]).range([0, summary_width])
            summary_update.selectAll(".xaxis")
                        .transition().duration(100)
                        .call(d3.axisBottom(summary_x).ticks(3).tickFormat(d3.format("d")));
            summary_y.domain([0, Math.min(100, d3.max(new_race_counts, function(d) { return d.pct; })*1.3)]);
            summary_update.selectAll(".yaxis").transition().duration(100).call(d3.axisLeft(summary_y));

            summary_line = d3.line()
            .x(function(d) {return summary_x(d.year);})
            .y(function(d) {return summary_y(d.pct);});
          

            // clips the ends of the lines to the graph width and height, otherwise the line crosses ove the axes for some reason
            summary_update.append('defs')
                  .append('clipPath')
                  .attr('id', 'clip')
                  .append('rect')
                  .attr('width', summary_width)
                  .attr('height', summary_height);

            summary_update.selectAll(".line").transition()
                    .attr("class", "line") 
                    .attr('clip-path', 'url(#clip)') 
                    .attr("fill", "none")
                    .attr("stroke", "#AB8D3F")
                    .attr("stroke-width", 1.9)
                    .attr("d", function(d){
                      return summary_line(d.values)
                    })


            // Update compare graph
            var new_all_data = all_data.filter(d => (d.year_ceremony >= newRange.begin) && (d.year_ceremony <= newRange.end))
            compare_x.domain([newRange.begin, newRange.end])
            compare_xAxis.transition().duration(100)
              .call(d3.axisBottom(compare_x).tickFormat(d3.format("d")))
              .selectAll("text")
              .attr("transform", "rotate(-15)");
            compare_y.domain([0, Math.min(50, d3.max(new_all_data, function(d) { return d.pct_race * 100; }))]);
            compare_yAxis.transition().duration(100).call(d3.axisLeft(compare_y));

            let filteredData = new_all_data.filter(d => categories.includes(categoryMappings[d.category]) && (d.fixed_race==='white'))
            let combinedData = []
            let element = {}
            filteredData.forEach( function(d) {
              if (d.award + "_" + d.year_ceremony in element) {
                element[d.award + "_" + d.year_ceremony] += (1 - d.pct_race) / categories.length
              }

              else {
                element[d.award + "_" + d.year_ceremony] = (1 - d.pct_race) / categories.length;
              }
            });

          var increments = [-2, -1, 1, 2];
          for (var key in element) {
            var count = 1;
            var sum = element[key];
            for (const inc of increments) {
              var year_ceremony = parseInt(key.split("_")[1]) + inc;
              var award = key.split("_")[0];
              var key2 = award + "_" + year_ceremony;
              if (key2 in element) {
                sum += element[key2];
                count += 1;
              }
            }
            element[key] = sum / count;
          }


            for (var key in element) {
              let award = key.split("_")[0];
              let year_ceremony = key.split("_")[1];
              combinedData.push({"award": award, "year_ceremony": year_ceremony, "pct_race": element[key]})
            }

            compare_svg.selectAll(".line").remove();
            
            for (var i=0; i<awards.length; i++){
            compare_svg.append("path")
              .datum(combinedData.filter(d => (d.award == awards[i]) ))
              .attr("class", "line") 
              .attr("id", awards[i].concat("Line"))
              .attr("d", compare_line)
              .attr("active", 0)
              .style("fill", "none")
              .style("stroke", line_color(awards[i]))
              .style("stroke-width", function(d) {
                if (awards[i] === "sag") {
                  return "3";
                }
                else {
                  return "1";
                }})
          }

            update(csv_data, newRange.begin, newRange.end, categories)

            let winners = newData.filter(d => d.winner == "TRUE");
            let nominees = newData.filter(d => d.winner == "FALSE")
            let alpha = Math.min(0.003, Math.max(0, 0.00045*winners.length - 0.015))
            simulationCircle.nodes(winners).alpha(alpha).alphaTarget(0).restart()
            simulationRing.nodes(nominees).alpha(alpha).alphaTarget(0).restart()

        });

        slider.range(1994, 2020);

        // // CATEGORY BUTTON LOGIC
        function handleCategoryChange(category) {
            return function(e){
                // if all categories selected, then select only the "All" button
                if (category == "all") {
                    // Outline all buttons except for the "All" button
                    var els = document.getElementsByClassName("btn")
                    for (el of els){
                        el.classList.remove('btn-light');
                        el.classList.add('btn-outline-light');
                    }
                    // fill the All button
                    document.getElementById("all-btn").classList.remove('btn-outline-light');
                    document.getElementById("all-btn").classList.add('btn-light');
                    categories = [actorCategory, actressCategory, actorSupCategory, actressSupCategory]
                } else if (categories.includes(category)) {
                    if (categories.length == 4) { // if all categories were previously selected, then just select the single category
                        document.getElementById("all-btn").classList.remove('btn-light')
                        document.getElementById("all-btn").classList.add('btn-outline-light')
                        document.getElementsByName(category)[0].classList.remove('btn-outline-light')
                        document.getElementsByName(category)[0].classList.add('btn-light')
                        categories = [category]
                    } else { // the category was already selected, so remove it
                        document.getElementsByName(category)[0].classList.remove('btn-light')
                        document.getElementsByName(category)[0].classList.add('btn-outline-light')
                        var index = categories.indexOf(category);
                        categories.splice(index, 1);
                    }
                } else { // the category is not yet selected, so select it.
                    if (categories.length == 3) { // this is the only category not yet selected. now that it is, select "All"
                        var els = document.getElementsByClassName("btn")
                        for (el of els){
                            el.classList.remove('btn-light');
                            el.classList.add('btn-outline-light');
                        }
                        document.getElementById("all-btn").classList.remove('btn-outline-light');
                        document.getElementById("all-btn").classList.add('btn-light');
                    } else {
                        var el = document.getElementsByName(category)[0]
                        el.classList.add('btn-light')
                        el.classList.remove('btn-outline-light')
                    }
                    categories.push(category)
                    // then, sort alphabetically so the graph is consistent in ordering
                    categories = categories.sort()
                }
                update(csv_data, slider.range().begin, slider.range().end, categories)
                var newData = getData(slider.range().begin, slider.range().end).filter(d => categories.includes(d.category))
                var winners = newData.filter(d => d.winner == "TRUE");
                var nominees = newData.filter(d => d.winner == "FALSE")
                let alpha = Math.min(0.003, Math.max(0, 0.0005*winners.length - 0.01))
                // If there are multiple categories and they include supporting categories, do not
                // have alpha if the number of winners per category is under 18.
                if (categories.length > 1 && winners.length < 20 && (categories.includes("ACTOR IN A SUPPORTING ROLE") || categories.includes("ACTRESS IN A SUPPORTING ROLE"))) {
                    alpha = 0
                }
                console.log('alpha', alpha)
                simulationCircle.nodes(winners).alpha(alpha).alphaTarget(0).restart()
                simulationRing.nodes(nominees).alpha(alpha).alphaTarget(0).restart()


              let filteredData = all_data.filter(d => categories.includes(categoryMappings[d.category]) && (d.fixed_race==='white'))
              let combinedData = []
              let element = {}
              filteredData.forEach( function(d) {
                if (d.award + "_" + d.year_ceremony in element) {
                  element[d.award + "_" + d.year_ceremony] += (1 - d.pct_race) / categories.length
                }

                else {
                  element[d.award + "_" + d.year_ceremony] = (1 - d.pct_race) / categories.length;
                }
              });

              var increments = [-2, -1, 1, 2];
              for (var key in element) {
                var count = 1;
                var sum = element[key];
                for (const inc of increments) {
                  var year_ceremony = parseInt(key.split("_")[1]) + inc;
                  var award = key.split("_")[0];
                  var key2 = award + "_" + year_ceremony;
                  if (key2 in element) {
                    sum += element[key2];
                    count += 1;
                  }
                }
                element[key] = sum / count;
              }

              for (var key in element) {
                let award = key.split("_")[0];
                let year_ceremony = key.split("_")[1];
                combinedData.push({"award": award, "year_ceremony": year_ceremony, "pct_race": element[key]})
              }

              compare_svg.selectAll(".line").remove();
              // aggregate all the data
              for (var i=0; i<awards.length; i++){
                compare_svg.append("path")
                        .datum(combinedData.filter(d => (d.award === awards[i]) ))
                        .attr("class", "line")
                        .attr("id", awards[i].concat("Line"))
                        .attr("d", compare_line)
                        .attr("active", 0)
                        .style("fill", "none")
                        .style("stroke", line_color(awards[i]))
                        .style("stroke-width", function(d) {
                          if (awards[i] === "sag") {
                            return "3";
                          }
                          else {
                            return "1";
                          }})
              }

            }

        }
        document.getElementById("all-btn").addEventListener("click", handleCategoryChange("all"))
        document.getElementById("actor-btn").addEventListener("click", handleCategoryChange(actorCategory))
        document.getElementById("actress-btn").addEventListener("click", handleCategoryChange(actressCategory))
        document.getElementById("sup-actor-btn").addEventListener("click", handleCategoryChange(actorSupCategory))
        document.getElementById("sup-actress-btn").addEventListener("click", handleCategoryChange(actressSupCategory))
      })
    });
</script>
</body>